<!--bible.html ì›ë³¸-->
<!doctype html>
<html lang="ko">
<head>
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bible</title>

  <!-- ì—¬ê¸°ì„œë¶€í„° êµ¬ê¸€ í°íŠ¸ í†µí•© ë§í¬ì…ë‹ˆë‹¤ -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- ì£¼ì†Œ ëì— ì—”í„° ì—†ì´ í•œ ì¤„ë¡œ ì­‰ ì´ì–´ì ¸ì•¼ í•©ë‹ˆë‹¤! -->
<link href="https://fonts.googleapis.com/css2?family=Alef:wght@400;700&family=Heebo:wght@400;700&family=Nanum+Gothic:wght@400;700&family=Noto+Serif+Hebrew:wght@400;700&family=Playpen+Sans+Hebrew:wght@400;700&display=swap
 rel="stylesheet">

<style>
    /* 1. rootì— íˆë¸Œë¦¬ì–´ ì „ìš© í°íŠ¸ ë³€ìˆ˜ ì¶”ê°€ (ê¸°ë³¸ê°’ ì„¤ì •) */
    :root {
        --gap: 14px;
        --border: #e5e5e5;
        --muted: #666;
        --on: #0b5;
        --playing: #08f;
        --hebrew-font: "Noto Serif Hebrew", serif; /* íˆë¸Œë¦¬ì–´ ê¸°ë³¸ í°íŠ¸ ë³€ìˆ˜ */
    }

    body {
        margin: 0;
        padding: 18px;
        font-family: "Nanum Gothic", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: #fff;
        color: #111;
    }

    .wrap { max-width: 980px; margin: 0 auto; }
    .verse { border: 1px solid var(--border); border-radius: 14px; padding: 14px; margin: 0 0 var(--gap) 0; }
    .ref { font-weight: 700; margin: 0 0 8px 0; }

    /* 2. íˆë¸Œë¦¬ì–´ ë³¸ë¬¸ ìŠ¤íƒ€ì¼ (ë³€ìˆ˜ ì ìš©) */
    h1.he {
        margin: 0 0 10px 0;
        font-size: 1.9rem;
        line-height: 1.25;
        direction: rtl;
        unicode-bidi: plaintext;
        text-align: left;
        font-family: var(--hebrew-font) !important; /* ë³€ìˆ˜ë¡œ ë³€ê²½ */
    }

    .kor { margin: 0 0 10px 0; font-size: 0.9rem; color: #111; }
    .btnrow { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { border: 1px solid var(--border); background: #f7f7f7; padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 700; }
    button:hover { background: #f0f0f0; }
    button.playing { border-color: var(--playing); color: var(--playing); background: #eef6ff; }
    button.repeatOn { border-color: var(--on); color: var(--on); background: #eafff3; }

    .topbar {
        position: sticky;
        top: 8px;
        z-index: 999;
        background: #fff;
        padding: 10px 0;
        margin: 0 0 14px 0;
        border-bottom: 1px solid var(--border);
    }

    .navcenter {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 13px;
        color: var(--muted);
    }

    .navcenter select {
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fff;
        font-weight: 700;
    }

    .w { cursor: pointer; padding: 0 2px; border-radius: 6px; }
    .w:hover { background: #f3f6ff; }

    /* modal */
    .modalBg {
        position: fixed; inset: 0; background: rgba(0,0,0,.45);
        display: none; align-items: center; justify-content: center;
        padding: 18px; z-index: 2000;
    }
    .modalBg.on { display: flex; }
    .modal {
        width: min(1000px, 90vw);
        height: 60vh;
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0,0,0,.25);
        padding: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .modalTop { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 10px; }
    .closeBtn { border: 1px solid var(--border); background: #f7f7f7; padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 700; }

    /* 3. ëª¨ë‹¬ ë‚´ í° ë‹¨ì–´ ìŠ¤íƒ€ì¼ (ë³€ìˆ˜ ì ìš©) */
    .wordHead {
        margin: 20px 0;
        font-size: clamp(70px, 9vw, 140px);
        line-height: 1.1;
        direction: rtl;
        unicode-bidi: plaintext;
        text-align: center;
        font-family: var(--hebrew-font) !important; /* ë³€ìˆ˜ë¡œ ë³€ê²½ */
    }

    .modalBtns { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 10px; }
    .error { color: #c00; font-weight: 700; margin: 10px 0; }
    button:disabled { opacity: 0.4; cursor: default; }

    #fontSizeControl {
        position: fixed;
        top: 10px;
        right: 14px;
        z-index: 3000;
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 6px 10px;
        box-shadow: 0 6px 18px rgba(0,0,0,.15);
        font-size: 13px;
    }
</style>

</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="navcenter">
        
        <select id="bookSelect" aria-label="ì„±ê²½ ì„ íƒ"></select>
        <select id="chapterSelect" aria-label="ì¥ ì„ íƒ"></select>
        <span>ì¥</span>
      <button id="prevVerseBtn" style="padding:6px 10px;">&lt;</button>
        <select id="verseSelect" aria-label="ì ˆ ì´ë™"></select>
        <span>ì ˆ</span>
      <button id="nextVerseBtn" style="padding:6px 10px;">&gt;</button>
        <!--div id="fontSizeControl"-->
        <select id="fontSizeSelect"></select>
        <!--/div-->
        <select id="fontFamilySelect"></select>

      </div>
    </div>

    <div id="error" class="error" style="display:none;"></div>
    <div id="verses"></div>
  </div>

  <!-- Word Modal -->
  <div class="modalBg" id="modalBg" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalTop">
        <div style="font-weight:700; color:var(--muted); font-size:13px;">ë‹¨ì–´</div>
        <button class="closeBtn" id="closeModal">ë‹«ê¸°</button>
      </div>
      <h1 class="wordHead" id="modalWord"></h1>
      <div class="modalBtns">
        <button class="playBtn" id="wordPlay">ğŸ”Š</button>
        <button class="loopBtn" id="wordLoop">âˆ</button>
      </div>
    </div>
  </div>

  <script>
    // ì ˆ < > ì´ë™ ë³€ìˆ˜
    const prevVerseBtn = document.getElementById("prevVerseBtn");
    const nextVerseBtn = document.getElementById("nextVerseBtn");

    // ========= Data + routing =========
    const BOOKS = [
      { id:"genesis", label:"ì°½ì„¸ê¸°", maxCh:50, refPrefix:"ì°½ì„¸ê¸°" }
    ];

    const bookSelect = document.getElementById("bookSelect");
    const chapterSelect = document.getElementById("chapterSelect");
    const verseSelect = document.getElementById("verseSelect");
    const versesEl = document.getElementById("verses");
    const errorEl = document.getElementById("error");

    function qs(){
      const p = new URLSearchParams(location.search);
      return {
        b: p.get("b") || "genesis",
        c: Number(p.get("c") || "1"),
        v: Number(p.get("v") || "1"),
      };
    }
    function setQS(b,c,v){
      const p = new URLSearchParams(location.search);
      p.set("b", b);
      p.set("c", String(c));
      if (v) p.set("v", String(v));
      history.replaceState(null, "", `${location.pathname}?${p.toString()}${location.hash||""}`);
    }

    function cleanForTTS(text){
      return String(text)
        .replace(/[\/]/g, " ")
        .replace(/[Ö¾â€“â€”]/g, " ")
        .replace(/[.,;:!?×´×´'"]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    // ========= TTS (same behavior as g1.html) =========
    let voicesReady = false;
    let heVoice = null;

    function pickHebrewVoice(){
      const voices = window.speechSynthesis.getVoices() || [];
      heVoice = voices.find(v => (v.lang || "").toLowerCase().startsWith("he")) || null;
      voicesReady = true;
    }

    let playingV = null;     // verse number playing
    let repeatV = null;      // verse number repeating
    let VERSE_TEXTS = {};    // { [v:number]: hebrew string }

    function setBtnState(v){
      document.querySelectorAll(".playBtn[data-v]").forEach(b => b.classList.toggle("playing", Number(b.dataset.v) === v));
      document.querySelectorAll(".loopBtn[data-v]").forEach(b => b.classList.toggle("repeatOn", Number(b.dataset.v) === repeatV));
    }

    function stopAll(){
      try{ window.speechSynthesis.cancel(); }catch(e){}
      playingV = null;
      setBtnState(null);
    }

    function speakVerse(v, fromRepeat=false){
      v = Number(v);
      const text = VERSE_TEXTS[v];
      if (!text) return;

      if (playingV !== null && playingV !== v){
        stopAll();
      }
      if (repeatV !== null && repeatV !== v && !fromRepeat){
        repeatV = null;
      }

      const u = new SpeechSynthesisUtterance(cleanForTTS(text));
      if (!voicesReady) pickHebrewVoice();
      if (heVoice) u.voice = heVoice;
      u.lang = (heVoice && heVoice.lang) ? heVoice.lang : "he-IL";
      u.rate = 1.0;

      playingV = v;
      setBtnState(v);

      u.onend = () => {
        playingV = null;
        setBtnState(null);
        if (repeatV === v){
          setTimeout(() => speakVerse(v, true), 350);
        }
      };

      u.onerror = () => {
        playingV = null;
        setBtnState(null);
      };

      window.speechSynthesis.speak(u);
    }

    if ("speechSynthesis" in window){
      window.speechSynthesis.onvoiceschanged = () => pickHebrewVoice();
      pickHebrewVoice();
    }

    // Verse play/loop buttons (event delegation)
    document.addEventListener("click", (e) => {
      const p = e.target.closest(".playBtn[data-v]");
      const l = e.target.closest(".loopBtn[data-v]");

      if (p){
        const v = Number(p.dataset.v);
        if (repeatV !== null && repeatV !== v) repeatV = null;
        speakVerse(v);
        return;
      }

      if (l){
        const v = Number(l.dataset.v);
        if (repeatV === v){
          repeatV = null;
          setBtnState(playingV);
          return;
        }
        repeatV = v;
        setBtnState(playingV);
        speakVerse(v);
        return;
      }
    });

    // ========= Word popup (same UX as g1.html) =========
    const modalBg = document.getElementById("modalBg");
    const modalWord = document.getElementById("modalWord");
    const closeModalBtn = document.getElementById("closeModal");
    const wordPlay = document.getElementById("wordPlay");
    const wordLoop = document.getElementById("wordLoop");

    let currentWord = "";
    let wordRepeat = false;
    let wordAutoCount = 0;     // í˜„ì¬ ì¬ìƒ íšŸìˆ˜
    let wordAutoMax = 3;      // ìë™ ì¬ìƒ íšŸìˆ˜ 10ì„ 5/10/20ìœ¼ë¡œ ë³€ê²½í•˜ë©´ ìˆ«ìë§Œí¼ ë°˜ë³µí•¨, Infinity = ë¬´í•œëŒ€ ì¬ìƒ


    function openWordModal(word){
      currentWord = word || "";
      if (!currentWord) return;
      try{ window.speechSynthesis.cancel(); }catch(e){}
      // ë‹¨ì–´ ì¬ìƒì€ ì ˆ ë°˜ë³µì„ ëˆë‹¤
      repeatV = null;
      setBtnState(playingV);
      modalWord.textContent = currentWord;
      modalBg.classList.add("on");

      wordAutoCount = 0;
      wordRepeat = false; // ë¬´í•œë°˜ë³µ ë”
      speakWord();        // ìë™ ì‹œì‘

      
      // ğŸ”Š íŒì—… ì—´ë¦¬ë©´ ìë™ 1íšŒ ì¬ìƒ
      //wordRepeat = false;
      //wordLoop.classList.remove("repeatOn");
      //speakWord();
    }

    function closeWordModal(){
      try{ window.speechSynthesis.cancel(); }catch(e){}
      wordRepeat = false;
      wordPlay.classList.remove("playing");
      wordLoop.classList.remove("repeatOn");
      modalBg.classList.remove("on");
    }

    function speakWord(){
      if (!currentWord) return;
      const u = new SpeechSynthesisUtterance(cleanForTTS(currentWord));
      if (!voicesReady) pickHebrewVoice();
      if (heVoice) u.voice = heVoice;
      u.lang = (heVoice && heVoice.lang) ? heVoice.lang : "he-IL";
      u.rate = 1.0;

      wordPlay.classList.add("playing");

      u.onend = () => {
  	wordPlay.classList.remove("playing");

  	// ë¬´í•œ ë°˜ë³µ ëª¨ë“œë©´ ê³„ì†
  	if (wordRepeat){
    	setTimeout(() => speakWord(), 300);
    	return;
  	}

  	// ìë™ ë°˜ë³µ ì¹´ìš´íŠ¸ ì¦ê°€
  	wordAutoCount++;

  	if (wordAutoCount < wordAutoMax){
    	setTimeout(() => speakWord(), 300);
  	} else {
    	// ìë™ ë°˜ë³µ ì¢…ë£Œ â†’ íŒì—… ë‹«ê¸°
    	setTimeout(() => {
      	closeWordModal();
    	}, 300);
  }
};


      u.onerror = () => {
        wordPlay.classList.remove("playing");
      };

      window.speechSynthesis.speak(u);
    }

    document.addEventListener("click", (e) => {
      const w = e.target.closest(".w");
      if (w && w.dataset.w){
        openWordModal(w.dataset.w);
      }
    });

    closeModalBtn.addEventListener("click", closeWordModal);
    modalBg.addEventListener("click", (e) => {
      if (e.target === modalBg) 
        closeWordModal(); 
        wordAutoCount = 0;

    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modalBg.classList.contains("on")) closeWordModal();
    });

    wordPlay.addEventListener("click", () => {
      wordRepeat = false;
      wordLoop.classList.remove("repeatOn");
      try{ window.speechSynthesis.cancel(); }catch(e){}
      speakWord();
    });

    wordLoop.addEventListener("click", () => {
      wordRepeat = !wordRepeat;
      wordLoop.classList.toggle("repeatOn", wordRepeat);
      try{ window.speechSynthesis.cancel(); }catch(e){}
      if (wordRepeat) speakWord();
    });

    // ========= Render =========
    function escapeHTML(s){
      return String(s)
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function makeHebrewLineFromWords(words){
      // word.text is already tokenized (maqaf kept), make clickable spans
      return (words || []).map(w => {
        const t = w && w.text ? String(w.text) : "";
        if (!t) return "";
        const clean = t.replace(/[.,;:!?×´×³'"]/g, "");
        return `<span class="w" data-w="${escapeHTML(clean)}">${escapeHTML(t)}</span>`;
      }).join(" ");
    }

    function buildBookOptions(){
      bookSelect.innerHTML = "";
      for (const b of BOOKS){
        const opt = document.createElement("option");
        opt.value = b.id;
        opt.textContent = b.label;
        bookSelect.appendChild(opt);
      }
    }

    async function buildChapterOptions(bookId, current){
      chapterSelect.innerHTML = "";

      let existingChapters = [];

      for (let i = 1; i <= 50; i++){
        try{
          const res = await fetch(`./data/${bookId}/${i}.json`, { method:"HEAD", cache:"no-cache" });
          if (res.ok) existingChapters.push(i);
        }catch(e){}
      }

      if (!existingChapters.length) existingChapters = [1];

      for (const ch of existingChapters){
        const opt = document.createElement("option");
        opt.value = ch;
        opt.textContent = `${ch}`;
        chapterSelect.appendChild(opt);
      }

      chapterSelect.value = existingChapters.includes(current) ? String(current) : String(existingChapters[0]);
      return Number(chapterSelect.value);
    }

    function buildVerseOptions(versesObj, bookId, ch, currentV){
      verseSelect.innerHTML = "";
      const keys = Object.keys(versesObj || {}).map(Number).sort((a,b)=>a-b);
      const b = BOOKS.find(x => x.id === bookId) || BOOKS[0];

      for(const v of keys){
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = `${v}`;
        verseSelect.appendChild(opt);
      }
      const setV = keys.includes(currentV) ? currentV : (keys[0] || 1);
      verseSelect.value = String(setV);
      updateVerseNavButtons();
      return setV;
    }

    function updateVerseNavButtons(){
      const current = Number(verseSelect.value);
      const options = Array.from(verseSelect.options).map(o => Number(o.value));
      const min = Math.min(...options);
      const max = Math.max(...options);
    
      prevVerseBtn.disabled = (current === min);
      nextVerseBtn.disabled = (current === max);
    }


    function jumpToVerse(v){
      const el = document.getElementById(`v${v}`);
      if (!el) return;

      const y = el.getBoundingClientRect().top + window.pageYOffset;
      const barH = document.querySelector(".topbar")?.offsetHeight || 0;

      window.scrollTo({
        top: y - barH - 12,
        behavior: "smooth"
      });

      history.replaceState(null, "", `${location.pathname}${location.search}#v${v}`);
    }

    async function loadChapter(bookId, ch, focusV){
      errorEl.style.display = "none";
      errorEl.textContent = "";

      stopAll(); // stop any TTS when changing chapter
      repeatV = null;
      setBtnState(null);

      const url = `./data/${bookId}/${ch}.json`;

      let data;
      try{
        const res = await fetch(url, { cache: "no-cache" });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        data = await res.json();
      }catch(err){
        versesEl.innerHTML = "";
        errorEl.textContent = `ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆì–´ìš”: ${err && err.message ? err.message : err}`;
        errorEl.style.display = "block";
        return;
      }

      // render
      const versesObj = data.verses || {};
      VERSE_TEXTS = {};
      versesEl.innerHTML = "";

      const keys = Object.keys(versesObj).map(Number).sort((a,b)=>a-b);
      for (const v of keys){
        const item = versesObj[String(v)];
        if (!item) continue;

        const ref = item.reference || `${bookId} ${ch}:${v}`;
        const verseText = item.verseText || "";
        const words = Array.isArray(item.words) ? item.words : [];
        const korLine = (item.kor2 ?? item.kor ?? "");        // prefer words tokens for display (so popup works cleanly)
        const heHTML = words.length ? makeHebrewLineFromWords(words) : escapeHTML(verseText);

        VERSE_TEXTS[v] = verseText || words.map(w => w.text).join(" ");

        const sec = document.createElement("section");
        sec.className = "verse";
        sec.id = `v${v}`;
        sec.innerHTML = `
          <div class="ref">${escapeHTML(ref)}</div>
          <h1 class="he">${heHTML}</h1>
          <div class="kor">${escapeHTML(korLine)}</div>
          <div class="btnrow">
            <button class="playBtn" data-v="${v}">ğŸ”Š</button>
            <button class="loopBtn" data-v="${v}">âˆ</button>
          </div>
        `;
        versesEl.appendChild(sec);
      }

      const pickedV = buildVerseOptions(versesObj, bookId, ch, focusV);
      setQS(bookId, ch, pickedV);

      // jump after render
      requestAnimationFrame(() => jumpToVerse(pickedV));
    }

    // ========= Wire up =========
    async function init(){
      prevVerseBtn.addEventListener("click", () => {
      const current = Number(verseSelect.value);
      const options = Array.from(verseSelect.options).map(o => Number(o.value));
      const min = Math.min(...options);
    
      if (current > min){
        verseSelect.value = String(current - 1);
        verseSelect.dispatchEvent(new Event("change"));
      }
    });
    
    nextVerseBtn.addEventListener("click", () => {
      const current = Number(verseSelect.value);
      const options = Array.from(verseSelect.options).map(o => Number(o.value));
      const max = Math.max(...options);
    
      if (current < max){
        verseSelect.value = String(current + 1);
        verseSelect.dispatchEvent(new Event("change"));
      }
    });

      
      const { b, c, v } = qs();

      buildBookOptions();
      bookSelect.value = b;

      const realC = await buildChapterOptions(b, c);

      // handlers
      bookSelect.addEventListener("change", async () => {
        const nb = bookSelect.value;
        const realC = await buildChapterOptions(nb, 1);
        loadChapter(nb, realC, 1);
      });

      chapterSelect.addEventListener("change", () => {
        const nb = bookSelect.value;
        const nc = Number(chapterSelect.value);
        loadChapter(nb, nc, 1);
      });

      verseSelect.addEventListener("change", () => {
        const vv = Number(verseSelect.value);
        setQS(bookSelect.value, Number(chapterSelect.value), vv);
        jumpToVerse(vv);
        updateVerseNavButtons();
      });


      window.addEventListener("hashchange", () => {
        const m = (location.hash || "").match(/^#v(\d+)$/);
        if (!m) return;
        const vv = Number(m[1]);
        if (Number(verseSelect.value) !== vv){
          verseSelect.value = String(vv);
          setQS(bookSelect.value, Number(chapterSelect.value), vv);
        }
        jumpToVerse(vv);
      });

      loadChapter(b, realC, v);
    }

    init();
// ===== font size control =====
const fontSizeSelect = document.getElementById("fontSizeSelect");
const fontSizes = [14,16,18,20,22,24,26,28,32,36,40];

function applyFontSize(size){
  document.documentElement.style.fontSize = size + "px";
  localStorage.setItem("bibleFontSize", size);
}

(function initFontSize(){
  const saved = parseInt(localStorage.getItem("bibleFontSize")) || 18;

  fontSizes.forEach(s=>{
    const opt=document.createElement("option");
    opt.value=s;
    //opt.textContent=s+"px";
    opt.textContent = "í¬ê¸°: " + s + "px";
    if(s===saved) opt.selected=true;
    fontSizeSelect.appendChild(opt);
  });

  applyFontSize(saved);
})();

fontSizeSelect.addEventListener("change", ()=>{
  applyFontSize(parseInt(fontSizeSelect.value));
});

// ===== font family control =====
const fontFamilySelect = document.getElementById("fontFamilySelect");
const fontFamilies = [
  { name: "ì„¸ë¦¬í”„(ê¸°ë³¸)", value: "'Noto Serif Hebrew', serif" },
  { name: "ê³ ë”•(Heebo)", value: "'Heebo', sans-serif" },
  { name: "í˜„ëŒ€ì (Alef)", value: "'Alef', sans-serif" },
  { name: "í•„ê¸°ì²´(Playpen)", value: "'Playpen Sans Hebrew', cursive" }

];

function applyFontFamily(family) {
  // 1. CSS ë³€ìˆ˜ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  document.documentElement.style.setProperty('--hebrew-font', family, 'important');

  // 2. íŠ¹ì • í´ë˜ìŠ¤ì— ì§ì ‘ ê°•ì œ ì£¼ì… (ê°€ì¥ í™•ì‹¤í•œ ë°©ë²•)
  const targets = document.querySelectorAll('h1.he, .wordHead');
  targets.forEach(el => {
    el.style.fontFamily = family;
  });

  // 3. ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥
  localStorage.setItem("bibleFontFamily", family);
}


(function initFontFamily() {
  const saved = localStorage.getItem("bibleFontFamily") || "'Noto Serif Hebrew', serif";

  fontFamilies.forEach(f => {
    const opt = document.createElement("option");
    opt.value = f.value;
    opt.textContent =f.name;
    if (f.value === saved) opt.selected = true;
    fontFamilySelect.appendChild(opt);
  });

  // ì´ˆê¸° ë¡œë”© ì‹œ ì ìš©
  applyFontFamily(saved);
})();

fontFamilySelect.addEventListener("change", () => {
  applyFontFamily(fontFamilySelect.value);
});


  </script>
</body>
</html>
