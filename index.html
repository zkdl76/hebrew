<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>구약 히브리어 발음듣기</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 24px 0 40px;
      text-align: center;
      background: #fafafa;
    }
    h1 {
      margin-bottom: 20px;
      font-size: 26px;
      font-weight: 600;
    }
    .top-controls {
      margin-bottom: 12px;
      font-size: 14px;
    }
    .top-controls select,
    .top-controls button {
      font-size: 14px;
      padding: 4px 8px;
      margin: 0 2px;
    }
    .card {
      width: 80%;
      max-width: 720px;
      margin: 0 auto 18px;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      padding: 16px 14px 18px;
      box-sizing: border-box;
      position: relative;
    }
    .section-title {
      font-size: 15px;
      font-weight: 600;
      margin: 6px 0 10px;
      text-align: left;
    }
    .hebrew-display {
      font-size: clamp(28px, 6vw, 40px);
      margin: 8px 0 10px;
      direction: rtl;
      line-height: 1.4;
      word-spacing: 0.4em;
    }
    .hebrew-verse-small {
      font-size: clamp(20px, 4.5vw, 28px);
      margin: 4px 0 6px;
      direction: rtl;
      line-height: 1.4;
      word-spacing: 0.3em;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
    }
    .controls-row button,
    .controls-row select {
      font-size: 13px;
      padding: 4px 8px;
    }
    .label-inline {
      font-size: 13px;
      margin-right: 4px;
    }

    /* 캔버스 카드 */
    .canvas-container {
      position: relative;
      margin-top: 10px;
    }
    #traceCanvas {
      border-radius: 8px;
      border: 1px solid #ddd;
      background: rgba(255,255,255,0.5);
      touch-action: none;
    }
    .canvas-controls {
      margin-top: 6px;
      font-size: 12px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    /* 옵션 모달 */
    .modal-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.3);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal {
      background: #fff;
      border-radius: 10px;
      padding: 12px 14px;
      width: 280px;
      max-width: 90vw;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      text-align: left;
      box-sizing: border-box;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .modal-title {
      font-size: 14px;
      font-weight: 600;
    }
    .modal-close {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }
    .modal-row {
      margin: 6px 0;
      font-size: 13px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }
    .modal-row label {
      flex: 1;
    }
    .modal-row select,
    .modal-row input {
      flex: 1;
      font-size: 13px;
      padding: 2px 4px;
    }

    /* 자세히 모달 (내용 스크롤) */
    #detailBackdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      justify-content: center;
      align-items: center;
      z-index: 1100;
    }
    #detailModal {
      background: #fff;
      border-radius: 10px;
      width: 280px;
      max-width: 90vw;
      padding: 10px 12px 8px;
      box-sizing: border-box;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: flex;
      flex-direction: column;
      height: 260px; /* 고정 높이: 내용만 스크롤 */
    }
    #detailHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    #detailTitle {
      font-size: 14px;
      font-weight: 600;
    }
    #detailCloseBtn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }
    #detailBodyWrapper {
      flex: 1;
      overflow-y: auto;
      border-top: 1px solid #eee;
      border-bottom: 1px solid #eee;
      margin: 4px 0;
      padding: 4px 0;
    }
    #detailBody {
      font-size: 13px; /* 기본: 보통 */
      line-height: 1.5;
      white-space: pre-wrap;
    }
    #detailFooter {
      display: flex;
      justify-content: flex-end;
      gap: 4px;
      font-size: 11px;
    }
    #detailFooter button {
      font-size: 11px;
      padding: 2px 6px;
    }

    /* 모바일 최적화 */
    @media (max-width: 480px) {
      body {
        padding-top: 16px;
      }
      h1 {
        font-size: 22px;
        margin-bottom: 14px;
      }
      .card {
        width: 92%;
        padding: 12px 10px 14px;
      }
      .hebrew-display {
        font-size: clamp(26px, 7vw, 34px);
      }
      .hebrew-verse-small {
        font-size: clamp(18px, 5vw, 24px);
      }
    }
  </style>
</head>
<body>
  <h1>구약 히브리어 발음듣기</h1>

  <div class="top-controls">
    <select id="bookSelect">
      <option value="genesis">창세기</option>
    </select>
    <select id="chapterSelect">
      <option value="1">1장</option>
      <!-- 나중에 장 추가 가능 -->
    </select>
    <select id="verseSelect"></select>
    <button id="prevVerseBtn">이전절</button>
    <button id="nextVerseBtn">다음절</button>
    <button id="optionsBtn">옵션</button>
  </div>

  <div class="card">
    <div class="section-title">현재 단어 / 묶음</div>
    <div id="currentHebrew" class="hebrew-display">־</div>

    <div class="section-title">전체 절</div>
    <div id="fullVerseHebrew" class="hebrew-verse-small">־</div>

    <div class="controls-row">
      <span class="label-inline">단어 묶음:</span>
      <select id="groupSizeSelect">
        <option value="1">1단어</option>
        <option value="3">3단어</option>
        <option value="5">5단어</option>
        <option value="all">전체</option>
      </select>

      <button id="prevUnitBtn">이전</button>
      <button id="playBtn">재생</button>
      <button id="nextUnitBtn">다음</button>
      <button id="detailBtn">자세히</button>
    </div>

    <div class="canvas-container">
      <canvas id="traceCanvas"></canvas>
      <div class="canvas-controls">
        <label>
          <input type="checkbox" id="drawToggle" checked />
          필기 On/Off
        </label>
        <label>
          펜 두께
          <input type="range" id="penWidth" min="1" max="8" value="3" />
        </label>
        <button id="clearCanvasBtn">지우기</button>
      </div>
    </div>
  </div>

  <!-- 옵션 모달 -->
  <div id="optionsBackdrop" class="modal-backdrop">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">재생 옵션</div>
        <button class="modal-close" id="optionsCloseBtn">&times;</button>
      </div>

      <div class="modal-row">
        <label for="speedSelect">속도</label>
        <select id="speedSelect">
          <option value="verySlow">아주 느리게</option>
          <option value="slow">느리게</option>
          <option value="normal" selected>보통</option>
          <option value="fast">빠르게</option>
        </select>
      </div>

      <div class="modal-row">
        <label for="repeatCountInput">반복 횟수</label>
        <input id="repeatCountInput" type="number" min="1" max="10" value="1" />
      </div>

      <div class="modal-row">
        <label for="intervalInput">간격(ms)</label>
        <input id="intervalInput" type="number" min="100" max="5000" step="100" value="800" />
      </div>

      <div class="modal-row">
        <label for="detailFontSelect">자세히 글자 크기</label>
        <select id="detailFontSelect">
          <option value="small">작게</option>
          <option value="medium" selected>보통</option>
          <option value="large">크게</option>
        </select>
      </div>
    </div>
  </div>

  <!-- 자세히 모달 -->
  <div id="detailBackdrop">
    <div id="detailModal">
      <div id="detailHeader">
        <div id="detailTitle">단어 정보</div>
        <button id="detailCloseBtn">&times;</button>
      </div>
      <div id="detailBodyWrapper">
        <div id="detailBody"></div>
      </div>
      <div id="detailFooter">
        <span>글자 크기:</span>
        <button data-size="small">작게</button>
        <button data-size="medium">보통</button>
        <button data-size="large">크게</button>
      </div>
    </div>
  </div>

  <script>
    // ====== 상태 ======
    let chapterData = null;
    let currentBook = "genesis";
    let currentChapter = "1";
    let currentVerse = 1;
    let maxVerse = 1;

    let currentWords = [];        // 현재 절의 words 배열
    let currentUnits = [];        // 그룹된 단위들 [{text, startIndex, endIndex}]
    let currentUnitIndex = 0;     // 현재 몇 번째 단위인가

    // 옵션
    let ttsSpeed = "normal";
    let repeatCount = 1;
    let intervalMs = 800;

    // 캔버스
    let isDrawing = false;
    let lastX = 0, lastY = 0;
    let drawingEnabled = true;

    // ====== DOM 참조 ======
    const bookSelect = document.getElementById("bookSelect");
    const chapterSelect = document.getElementById("chapterSelect");
    const verseSelect = document.getElementById("verseSelect");

    const prevVerseBtn = document.getElementById("prevVerseBtn");
    const nextVerseBtn = document.getElementById("nextVerseBtn");

    const currentHebrewEl = document.getElementById("currentHebrew");
    const fullVerseHebrewEl = document.getElementById("fullVerseHebrew");

    const groupSizeSelect = document.getElementById("groupSizeSelect");
    const prevUnitBtn = document.getElementById("prevUnitBtn");
    const nextUnitBtn = document.getElementById("nextUnitBtn");
    const playBtn = document.getElementById("playBtn");
    const detailBtn = document.getElementById("detailBtn");

    const optionsBtn = document.getElementById("optionsBtn");
    const optionsBackdrop = document.getElementById("optionsBackdrop");
    const optionsCloseBtn = document.getElementById("optionsCloseBtn");
    const speedSelect = document.getElementById("speedSelect");
    const repeatCountInput = document.getElementById("repeatCountInput");
    const intervalInput = document.getElementById("intervalInput");
    const detailFontSelect = document.getElementById("detailFontSelect");

    const detailBackdrop = document.getElementById("detailBackdrop");
    const detailCloseBtn = document.getElementById("detailCloseBtn");
    const detailBody = document.getElementById("detailBody");
    const detailFooter = document.getElementById("detailFooter");

    const traceCanvas = document.getElementById("traceCanvas");
    const drawToggle = document.getElementById("drawToggle");
    const penWidthInput = document.getElementById("penWidth");
    const clearCanvasBtn = document.getElementById("clearCanvasBtn");

    const bookFileMap = {
      "genesis": {
        "1": "data/genesis/1.json"
      }
    };

    // ====== 초기화 ======
    document.addEventListener("DOMContentLoaded", () => {
      setupCanvas();
      attachEvents();
      loadChapter(currentBook, currentChapter);
    });

    function attachEvents() {
      bookSelect.addEventListener("change", () => {
        currentBook = bookSelect.value;
        currentChapter = chapterSelect.value;
        loadChapter(currentBook, currentChapter);
      });

      chapterSelect.addEventListener("change", () => {
        currentChapter = chapterSelect.value;
        loadChapter(currentBook, currentChapter);
      });

      verseSelect.addEventListener("change", () => {
        const v = Number(verseSelect.value);
        if (!isNaN(v)) {
          currentVerse = v;
          loadVerse(currentVerse);
        }
      });

      prevVerseBtn.addEventListener("click", () => {
        if (currentVerse > 1) {
          currentVerse--;
          verseSelect.value = String(currentVerse);
          loadVerse(currentVerse);
        }
      });

      nextVerseBtn.addEventListener("click", () => {
        if (currentVerse < maxVerse) {
          currentVerse++;
          verseSelect.value = String(currentVerse);
          loadVerse(currentVerse);
        }
      });

      groupSizeSelect.addEventListener("change", () => {
        rebuildUnits();
        renderCurrentUnit();
      });

      prevUnitBtn.addEventListener("click", () => {
        if (currentUnits.length === 0) return;
        if (currentUnitIndex === 0) {
          currentUnitIndex = currentUnits.length - 1;
        } else {
          currentUnitIndex--;
        }
        renderCurrentUnit();
      });

      nextUnitBtn.addEventListener("click", () => {
        if (currentUnits.length === 0) return;
        currentUnitIndex = (currentUnitIndex + 1) % currentUnits.length;
        renderCurrentUnit();
      });

      playBtn.addEventListener("click", () => {
        playCurrentUnit();
      });

      detailBtn.addEventListener("click", () => {
        openDetailModal();
      });

      // 옵션 모달
      optionsBtn.addEventListener("click", () => {
        optionsBackdrop.style.display = "flex";
      });
      optionsCloseBtn.addEventListener("click", () => {
        optionsBackdrop.style.display = "none";
        applyOptionsFromModal();
      });
      optionsBackdrop.addEventListener("click", (e) => {
        if (e.target === optionsBackdrop) {
          optionsBackdrop.style.display = "none";
          applyOptionsFromModal();
        }
      });

      // 자세히 모달
      detailCloseBtn.addEventListener("click", closeDetailModal);
      detailBackdrop.addEventListener("click", (e) => {
        if (e.target === detailBackdrop) {
          closeDetailModal();
        }
      });

      detailFooter.addEventListener("click", (e) => {
        if (e.target.tagName === "BUTTON") {
          const size = e.target.getAttribute("data-size");
          setDetailFontSize(size);
        }
      });

      // 캔버스
      drawToggle.addEventListener("change", () => {
        drawingEnabled = drawToggle.checked;
      });

      clearCanvasBtn.addEventListener("click", clearCanvas);
      window.addEventListener("resize", resizeCanvas);
    }

    // ====== JSON 로딩 ======
    function loadChapter(book, chapter) {
      const path = bookFileMap[book] && bookFileMap[book][chapter];
      if (!path) {
        alert("아직 준비되지 않은 장입니다.");
        return;
      }

      fetch(path)
        .then(res => res.json())
        .then(data => {
          chapterData = data;
          setupVersesFromData();
        })
        .catch(err => {
          console.error("JSON 로딩 오류:", err);
          alert("데이터 로딩 중 오류가 발생했습니다.");
        });
    }

    function setupVersesFromData() {
      if (!chapterData || !chapterData.verses) return;

      const verseKeys = Object.keys(chapterData.verses)
        .map(Number)
        .sort((a, b) => a - b);

      if (verseKeys.length === 0) return;

      maxVerse = verseKeys[verseKeys.length - 1];

      verseSelect.innerHTML = "";
      verseKeys.forEach(v => {
        const opt = document.createElement("option");
        opt.value = String(v);
        opt.textContent = v + "절";
        verseSelect.appendChild(opt);
      });

      if (!verseKeys.includes(currentVerse)) {
        currentVerse = verseKeys[0];
      }
      verseSelect.value = String(currentVerse);
      loadVerse(currentVerse);
    }

    function loadVerse(verseNum) {
      if (!chapterData || !chapterData.verses) return;
      const verseObj = chapterData.verses[String(verseNum)];
      if (!verseObj) return;

      currentVerse = verseNum;
      currentWords = verseObj.words || [];

      fullVerseHebrewEl.textContent = verseObj.verseText || "־";

      rebuildUnits();
      currentUnitIndex = 0;
      renderCurrentUnit();
      clearCanvas();
    }

    // ====== 단위(그룹) 구성 ======
    function rebuildUnits() {
      currentUnits = [];
      currentUnitIndex = 0;

      if (!currentWords || currentWords.length === 0) {
        currentHebrewEl.textContent = "단어 없음";
        return;
      }

      const groupValue = groupSizeSelect.value;
      if (groupValue === "all") {
        const text = currentWords.map(w => w.text).join(" ");
        currentUnits.push({
          text,
          startIndex: 0,
          endIndex: currentWords.length - 1
        });
      } else {
        const size = Number(groupValue) || 1;
        for (let i = 0; i < currentWords.length; i += size) {
          const slice = currentWords.slice(i, i + size);
          const text = slice.map(w => w.text).join(" ");
          currentUnits.push({
            text,
            startIndex: i,
            endIndex: Math.min(i + size - 1, currentWords.length - 1)
          });
        }
      }
    }

    function renderCurrentUnit() {
      if (currentUnits.length === 0) {
        currentHebrewEl.textContent = "단어 없음";
        return;
      }
      const unit = currentUnits[currentUnitIndex];
      currentHebrewEl.textContent = unit.text;
    }

    // ====== TTS ======
    function getRateFromSpeed(speed) {
      switch (speed) {
        case "verySlow": return 0.4;
        case "slow": return 0.7;
        case "fast": return 1.4;
        case "normal":
        default: return 1.0;
      }
    }

    function playCurrentUnit() {
      if (!window.speechSynthesis) {
        alert("이 브라우저에서는 TTS를 지원하지 않습니다.");
        return;
      }
      if (currentUnits.length === 0) return;

      const unit = currentUnits[currentUnitIndex];
      const indices = [];
      for (let i = unit.startIndex; i <= unit.endIndex; i++) {
        indices.push(i);
      }

      const wordsToSpeak = indices.map(i => currentWords[i]).filter(Boolean);
      if (wordsToSpeak.length === 0) return;

      const rate = getRateFromSpeed(ttsSpeed);
      const repeat = repeatCount;
      const gap = intervalMs;

      function speakSequence(repLeft) {
        let idx = 0;
        function speakNext() {
          if (idx >= wordsToSpeak.length) {
            repLeft--;
            if (repLeft > 0) {
              idx = 0;
              setTimeout(speakNext, gap);
            }
            return;
          }
          const w = wordsToSpeak[idx];
          const utter = new SpeechSynthesisUtterance(w.pron || w.text);
          utter.lang = "ko-KR"; // 발음 표기는 한글 기준
          utter.rate = rate;
          utter.onend = () => {
            idx++;
            setTimeout(speakNext, gap);
          };
          speechSynthesis.speak(utter);
        }
        speakNext();
      }

      speakSequence(repeat);
    }

    function applyOptionsFromModal() {
      ttsSpeed = speedSelect.value;
      repeatCount = Math.max(1, Number(repeatCountInput.value) || 1);
      intervalMs = Math.max(100, Number(intervalInput.value) || 800);
      const fontSizeKey = detailFontSelect.value;
      setDetailFontSize(fontSizeKey);
    }

    function setDetailFontSize(sizeKey) {
      switch (sizeKey) {
        case "small":
          detailBody.style.fontSize = "12px";
          break;
        case "large":
          detailBody.style.fontSize = "15px";
          break;
        case "medium":
        default:
          detailBody.style.fontSize = "13px";
          break;
      }
    }

    // ====== 자세히 모달 ======
    function openDetailModal() {
      if (!currentWords || currentWords.length === 0 || currentUnits.length === 0) {
        detailBody.textContent = "단어 정보가 없습니다.";
      } else {
        const unit = currentUnits[currentUnitIndex];
        const lines = [];
        for (let i = unit.startIndex; i <= unit.endIndex; i++) {
          const w = currentWords[i];
          if (!w) continue;
          lines.push(
            [
              `히브리어: ${w.text}`,
              `발음: ${w.pron || ""}`,
              `기본 뜻: ${w.meaning || ""}`,
              `형태소: ${w.morph || ""}`,
              `어근: ${w.root || ""}`,
              `개역: ${w.kor || ""}`
            ].join("\n")
          );
        }
        detailBody.textContent = lines.join("\n\n----------------------\n\n");
      }
      detailBackdrop.style.display = "flex";
    }

    function closeDetailModal() {
      detailBackdrop.style.display = "none";
    }

    // ====== 캔버스 ======
    function setupCanvas() {
      resizeCanvas();

      const ctx = traceCanvas.getContext("2d");
      ctx.lineCap = "round";

      function getPos(evt) {
        const rect = traceCanvas.getBoundingClientRect();
        if (evt.touches && evt.touches.length > 0) {
          return {
            x: evt.touches[0].clientX - rect.left,
            y: evt.touches[0].clientY - rect.top
          };
        } else {
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        }
      }

      function startDraw(evt) {
        if (!drawingEnabled) return;
        isDrawing = true;
        const pos = getPos(evt);
        lastX = pos.x;
        lastY = pos.y;
      }

      function moveDraw(evt) {
        if (!isDrawing || !drawingEnabled) return;
        evt.preventDefault();
        const ctx = traceCanvas.getContext("2d");
        const pos = getPos(evt);
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.lineWidth = Number(penWidthInput.value) || 3;
        ctx.stroke();
        lastX = pos.x;
        lastY = pos.y;
      }

      function endDraw() {
        isDrawing = false;
      }

      // 마우스
      traceCanvas.addEventListener("mousedown", startDraw);
      traceCanvas.addEventListener("mousemove", moveDraw);
      window.addEventListener("mouseup", endDraw);

      // 터치
      traceCanvas.addEventListener("touchstart", startDraw, { passive: false });
      traceCanvas.addEventListener("touchmove", moveDraw, { passive: false });
      window.addEventListener("touchend", endDraw);
      window.addEventListener("touchcancel", endDraw);
    }

    function resizeCanvas() {
      const rect = fullVerseHebrewEl.getBoundingClientRect();
      const width = Math.min(window.innerWidth * 0.9, 700);
      const height = rect.height * 1.6 + 40; // 절 높이 기준으로 대략 조정
      traceCanvas.width = width;
      traceCanvas.height = Math.max(120, height);
      clearCanvas();
    }

    function clearCanvas() {
      const ctx = traceCanvas.getContext("2d");
      ctx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
    }
  </script>
</body>
</html>
